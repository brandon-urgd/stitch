name: Deploy Stitch with CloudFormation

on:
  push:
    branches: [ main ]      # Auto-deploy to dev
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy (dev, staging, prod)'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod
      confirm_prod:
        description: 'For PROD: Type "DEPLOY" to confirm'
        required: false
        type: string

permissions:
  contents: read
  id-token: write

jobs:
  version:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.VERSION }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Resolve VERSION
        id: version
        run: |
          echo "üîç Resolving VERSION..."
          
          if [ -f "VERSION" ]; then
            VERSION=$(cat VERSION | tr -d '\n\r')
            echo "‚úÖ Found VERSION file: $VERSION"
          else
            # Use commit SHA as primary version for build-once, promote-many
            VERSION=$(git rev-parse --short HEAD)
            echo "‚úÖ Using commit SHA as version: $VERSION"
          fi
          
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT
          echo "‚úÖ Resolved VERSION: $VERSION"

  security-checks:
    runs-on: ubuntu-latest
    needs: version
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install cfn-lint
        run: pip install cfn-lint

      - name: Install Checkov
        run: pip install checkov

      - name: Install Semgrep
        run: pip install semgrep

      - name: Lint CloudFormation
        run: |
          echo "üîç Running CloudFormation linting..."
          echo "Running: cfn-lint cloudformation/*.yaml --ignore-checks W3005"
          
          if cfn-lint cloudformation/*.yaml --ignore-checks W3005 2>&1; then
            echo "‚úÖ CloudFormation linting passed"
          else
            echo "‚ùå CloudFormation linting failed"
            echo "üîç Full cfn-lint output:"
            cfn-lint cloudformation/*.yaml --ignore-checks W3005
            exit 1
          fi

      - name: Run Checkov Security Scan
        run: |
          echo "üîç Running Checkov security scan..."
          echo "Checking for CloudFormation files..."
          ls -la cloudformation/
          
          # Run Checkov with approved exceptions and capture both stdout and stderr
          checkov -f cloudformation/stitch-infrastructure.yaml --framework cloudformation --output cli --output-file-path /tmp/checkov-results.txt --skip-check CKV_AWS_18,CKV_AWS_21,CKV_AWS_53,CKV_AWS_54,CKV_AWS_55,CKV_AWS_56,CKV_AWS_117,CKV_AWS_59,CKV_AWS_86,CKV_AWS_68 2>&1 | tee /tmp/checkov-output.txt
          CHECKOV_EXIT_CODE=${PIPESTATUS[0]}
          
          echo "Checkov exit code: $CHECKOV_EXIT_CODE"
          
          # Check if there are any failures in the results
          if [ -f /tmp/checkov-results.txt ]; then
            if grep -q "FAILED" /tmp/checkov-results.txt; then
              echo "‚ùå Checkov security scan found issues"
              echo "üîç Checkov results:"
              cat /tmp/checkov-results.txt
              echo ""
              echo "üîç Checkov output:"
              cat /tmp/checkov-output.txt
              exit 1
            else
              echo "‚úÖ Checkov security scan passed"
            fi
          else
            echo "‚úÖ Checkov security scan passed (no results file generated)"
          fi

      - name: Run Semgrep Security Scan
        run: |
          echo "üîç Running Semgrep security scan..."
          semgrep --config=auto --json --output=/tmp/semgrep-results.json .
          
          # Check if there are any findings
          if [ -s /tmp/semgrep-results.json ]; then
            findings=$(jq '.results | length' /tmp/semgrep-results.json)
            if [ "$findings" -gt 0 ]; then
              echo "‚ùå Semgrep found $findings security issues"
              echo "üîç Semgrep results:"
              cat /tmp/semgrep-results.json
              exit 1
            else
              echo "‚úÖ Semgrep security scan passed"
            fi
          else
            echo "‚úÖ Semgrep security scan passed"
          fi

      - name: Validate S3 ACLs
        run: |
          echo "Checking S3 bucket ACLs (should be private)..."
          if grep -r "AWS::S3::Bucket" cloudformation/; then
            if grep -r "PublicAccessBlockConfiguration.*false\|AccessControl.*PublicRead\|AccessControl.*PublicReadWrite" cloudformation/; then
              echo "‚ùå S3 buckets found with public access"
              exit 1
            else
              echo "‚úÖ S3 buckets properly configured with private access"
            fi
          else
            echo "‚ÑπÔ∏è  No S3 buckets found"
          fi

      - name: Validate DeletionPolicy
        run: |
          echo "Checking DeletionPolicy on critical resources..."
          if grep -r "AWS::S3::Bucket\|AWS::Logs::LogGroup" cloudformation/; then
            if ! grep -r "DeletionPolicy.*Retain\|DeletionPolicy.*Delete" cloudformation/; then
              echo "‚ùå Critical resources found without DeletionPolicy"
              exit 1
            else
              echo "‚úÖ Critical resources have DeletionPolicy configured"
            fi
          else
            echo "‚ÑπÔ∏è  No critical resources found"
          fi

  deploy-layer:
    runs-on: ubuntu-latest
    needs: [version, security-checks]
    if: github.event_name == 'push' || github.event.inputs.environment == 'dev'
    outputs:
      layer_version: ${{ steps.upload_layer.outputs.LAYER_VERSION }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::198919428218:role/urgd-stitch-deploy
          aws-region: ${{ secrets.AWS_REGION || 'us-west-2' }}
          audience: sts.amazonaws.com
      
      - name: Build Lambda Layer
        run: |
          VERSION="${{ needs.version.outputs.version }}"
          echo "üî® Building Lambda layer for version: $VERSION"
          
          mkdir -p layer-build/python
          pip install -r layers/svg-embroidery/requirements.txt -t layer-build/python/
          
          cd layer-build
          zip -r ../svg-embroidery-layer-${VERSION}.zip python/
          cd ..
          
          echo "‚úÖ Layer built: svg-embroidery-layer-${VERSION}.zip"
      
      - name: Upload Layer to S3
        id: upload_layer
        run: |
          VERSION="${{ needs.version.outputs.version }}"
          aws s3 cp svg-embroidery-layer-${VERSION}.zip \
            s3://urgd-applicationdata/stitch/layers/${VERSION}/svg-embroidery.zip \
            --region us-west-2
          
          echo "LAYER_VERSION=${VERSION}" >> $GITHUB_OUTPUT
          echo "‚úÖ Layer uploaded to s3://urgd-applicationdata/stitch/layers/${VERSION}/svg-embroidery.zip"

  build-shield-lambdas:
    runs-on: ubuntu-latest
    needs: [version, security-checks]
    if: github.event_name == 'push' || github.event.inputs.environment == 'dev'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Build Shield integration Lambdas
        run: |
          VERSION="${{ needs.version.outputs.version }}"
          echo "üî® Building Shield integration Lambdas for version: $VERSION"
          
          mkdir -p artifacts
          
          # Build upload URL generator
          cd lambdas
          zip -r ../artifacts/upload-url-generator-${VERSION}.zip upload_url_generator.py
          
          # Build status checker
          zip -r ../artifacts/status-checker-${VERSION}.zip status_checker.py
          
          # Build shield callback
          zip -r ../artifacts/shield-callback-${VERSION}.zip shield_callback.py
          cd ..
          
          echo "‚úÖ Shield integration Lambdas built successfully"
          echo "üì¶ Upload URL Generator: upload-url-generator-${VERSION}.zip"
          echo "üì¶ Status Checker: status-checker-${VERSION}.zip"
          echo "üì¶ Shield Callback: shield-callback-${VERSION}.zip"
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::198919428218:role/urgd-stitch-deploy
          aws-region: ${{ secrets.AWS_REGION || 'us-west-2' }}
          audience: sts.amazonaws.com
      
      - name: Upload Shield Lambda artifacts
        run: |
          VERSION="${{ needs.version.outputs.version }}"
          echo "üì¶ Uploading Shield Lambda artifacts for version: $VERSION"
          
          aws s3 cp artifacts/upload-url-generator-${VERSION}.zip \
            s3://urgd-applicationdata/stitch/artifacts/${VERSION}/upload-url-generator-${VERSION}.zip \
            --region us-west-2
          
          aws s3 cp artifacts/status-checker-${VERSION}.zip \
            s3://urgd-applicationdata/stitch/artifacts/${VERSION}/status-checker-${VERSION}.zip \
            --region us-west-2
          
          aws s3 cp artifacts/shield-callback-${VERSION}.zip \
            s3://urgd-applicationdata/stitch/artifacts/${VERSION}/shield-callback-${VERSION}.zip \
            --region us-west-2
          
          echo "‚úÖ Shield Lambda artifacts uploaded to S3"

  deploy:
    runs-on: ubuntu-latest
    needs: [version, security-checks, deploy-layer, build-shield-lambdas]
    if: always() && (needs.version.result == 'success' && needs.security-checks.result == 'success' && (needs.deploy-layer.result == 'success' || needs.deploy-layer.result == 'skipped') && (needs.build-shield-lambdas.result == 'success' || needs.build-shield-lambdas.result == 'skipped'))
    permissions:
      id-token: write
      contents: read
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Determine environment
      id: env
      env:
        GITHUB_EVENT_NAME: ${{ github.event_name }}
        GITHUB_REF: ${{ github.ref }}
        GITHUB_INPUT_ENVIRONMENT: ${{ github.event.inputs.environment }}
      run: |
        # Check if this is a manual workflow dispatch first
        if [ "$GITHUB_EVENT_NAME" = "workflow_dispatch" ] && [ -n "$GITHUB_INPUT_ENVIRONMENT" ]; then
          echo "ENVIRONMENT=$GITHUB_INPUT_ENVIRONMENT" >> $GITHUB_ENV
          if [ "$GITHUB_INPUT_ENVIRONMENT" = "prod" ]; then
            echo "WAF_ENVIRONMENT=prod" >> $GITHUB_ENV
          else
            echo "WAF_ENVIRONMENT=nonprod" >> $GITHUB_ENV
          fi
          echo "environment=$GITHUB_INPUT_ENVIRONMENT" >> $GITHUB_OUTPUT
        elif [ "$GITHUB_REF" = "refs/heads/main" ]; then
          echo "ENVIRONMENT=dev" >> $GITHUB_ENV
          echo "WAF_ENVIRONMENT=nonprod" >> $GITHUB_ENV
          echo "environment=dev" >> $GITHUB_OUTPUT
        else
          echo "‚ùå Invalid workflow trigger: $GITHUB_EVENT_NAME on $GITHUB_REF"
          echo "‚ùå Expected: push to main OR workflow_dispatch with environment input"
          exit 1
        fi
        echo "‚úÖ Environment determined: ${{ env.ENVIRONMENT }}"

    - name: Validate Production Deployment
      if: github.event.inputs.environment == 'prod'
      env:
        GITHUB_INPUT_CONFIRM_PROD: ${{ github.event.inputs.confirm_prod }}
      run: |
        if [ "$GITHUB_INPUT_CONFIRM_PROD" != "DEPLOY" ]; then
          echo "‚ùå Production deployment requires confirmation. Please type 'DEPLOY' in the confirm_prod field."
          exit 1
        fi
        echo "‚úÖ Production deployment confirmed"
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'
        
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: arn:aws:iam::198919428218:role/urgd-stitch-deploy
        aws-region: us-west-2

    - name: Prepare Shield Registration
      run: |
        VERSION="${{ needs.version.outputs.version }}"
        echo "üìù Preparing Shield registration for version: $VERSION"
        
        # Get Shield registration Lambda ARN from SSM (Shield is always in prod)
        echo "üîç Getting Shield registration Lambda ARN..."
        SHIELD_REGISTRATION_ARN=$(aws ssm get-parameter \
          --name "/urgd/shield/registration_function_arn" \
          --query 'Parameter.Value' \
          --output text \
          --region us-west-2)
        
        if [ "$SHIELD_REGISTRATION_ARN" = "None" ] || [ -z "$SHIELD_REGISTRATION_ARN" ]; then
          echo "‚ùå Shield registration Lambda ARN not found in SSM"
          echo "üîç Available Shield parameters:"
          aws ssm get-parameters-by-path \
            --path "/urgd/shield/" \
            --query 'Parameters[].Name' \
            --output table \
            --region us-west-2
          exit 1
        fi
        
        echo "‚úÖ Shield registration Lambda ARN: $SHIELD_REGISTRATION_ARN"
        echo "SHIELD_REGISTRATION_ARN=$SHIELD_REGISTRATION_ARN" >> $GITHUB_ENV
        
        # Always register after stack creation since callback Lambda doesn't exist yet
        echo "‚ÑπÔ∏è  Will register with Shield after stack creation (callback Lambda doesn't exist yet)"
        echo "SKIP_REGISTRATION=true" >> $GITHUB_ENV

    - name: Generate parameter files
      if: github.event_name == 'push' || github.event.inputs.environment == 'dev'
      run: |
        VERSION="${{ needs.version.outputs.version }}"
        echo "üìù Generating parameter files for version: $VERSION"
        
        # Use Shield resources from registration or fallback to SSM
        if [ -n "$SHIELD_BUCKET_NAME" ] && [ -n "$SHIELD_BUCKET_ARN" ]; then
          echo "‚úÖ Using Shield resources from registration"
        else
          echo "üîç Fetching Shield parameters from SSM as fallback..."
          SHIELD_BUCKET_NAME=$(aws ssm get-parameter \
            --name "/urgd/shield/quarantine_bucket_name" \
            --query 'Parameter.Value' \
            --output text \
            --region us-west-2)
          
          SHIELD_BUCKET_ARN=$(aws ssm get-parameter \
            --name "/urgd/shield/quarantine_bucket_arn" \
            --query 'Parameter.Value' \
            --output text \
            --region us-west-2)
        fi
        
        # Get EventBridge rule ARN from SSM (still needed for Lambda permissions)
        SHIELD_EVENTBRIDGE_RULE_ARN=$(aws ssm get-parameter \
          --name "/urgd/shield/eventbridge_rule_arn" \
          --query 'Parameter.Value' \
          --output text \
          --region us-west-2)
        
        echo "‚úÖ Shield parameters ready:"
        echo "  - Bucket Name: $SHIELD_BUCKET_NAME"
        echo "  - Bucket ARN: $SHIELD_BUCKET_ARN"
        echo "  - EventBridge Rule ARN: $SHIELD_EVENTBRIDGE_RULE_ARN"
        echo "  - Registration Lambda ARN: $SHIELD_REGISTRATION_ARN"
        
        mkdir -p parameter-files
        
        for env in dev staging prod; do
          cat > parameter-files/$env.json << EOF
        [
          {"ParameterKey": "Environment", "ParameterValue": "$env"},
          {"ParameterKey": "GitCommit", "ParameterValue": "$VERSION"},
          {"ParameterKey": "StitchFunctionCodeKey", "ParameterValue": "stitch/artifacts/$VERSION/stitch-function-$VERSION.zip"},
          {"ParameterKey": "StitchLayerCodeKey", "ParameterValue": "stitch/layers/$VERSION/svg-embroidery.zip"},
          {"ParameterKey": "UploadUrlGeneratorCodeKey", "ParameterValue": "stitch/artifacts/$VERSION/upload-url-generator-$VERSION.zip"},
          {"ParameterKey": "StatusCheckerCodeKey", "ParameterValue": "stitch/artifacts/$VERSION/status-checker-$VERSION.zip"},
          {"ParameterKey": "ShieldCallbackCodeKey", "ParameterValue": "stitch/artifacts/$VERSION/shield-callback-$VERSION.zip"},
          {"ParameterKey": "ShieldBucketName", "ParameterValue": "$SHIELD_BUCKET_NAME"},
          {"ParameterKey": "ShieldBucketArn", "ParameterValue": "$SHIELD_BUCKET_ARN"},
          {"ParameterKey": "ShieldEventBridgeRuleArn", "ParameterValue": "$SHIELD_EVENTBRIDGE_RULE_ARN"},
          {"ParameterKey": "AcmCertArnApiRegion", "ParameterValue": "arn:aws:acm:us-west-2:198919428218:certificate/1527d0ac-b0e3-4d3b-b003-a3234ca35935"},
          {"ParameterKey": "AcmCertArnCloudFront", "ParameterValue": "arn:aws:acm:us-east-1:198919428218:certificate/1bb45d38-488a-4799-839c-2b9895da7f47"},
          {"ParameterKey": "UrgdDevHostedZoneId", "ParameterValue": "Z01725332W8W14423YXSC"},
          {"ParameterKey": "UrgdStudiosHostedZoneId", "ParameterValue": "Z0338626TGE7PTZDLIT1"}
        ]
        EOF
        done
        
        echo "‚úÖ Parameter files generated with Shield integration parameters"

    - name: Copy parameter files for promotions
      if: github.event_name == 'workflow_dispatch' && github.event.inputs.environment != 'dev'
      run: |
        echo "üìã Copying parameter files from original dev build for promotion"
        
        # For promotions, we need to find the version that the current dev stack is using
        echo "üîç Finding version used by current dev stack..."
        
        # Get the GitCommit parameter from the dev stack
        ORIGINAL_VERSION=$(aws cloudformation describe-stacks \
          --stack-name "urgd-stitch-dev" \
          --query 'Stacks[0].Parameters[?ParameterKey==`GitCommit`].ParameterValue' \
          --output text \
          --region us-west-2)
        
        if [ -z "$ORIGINAL_VERSION" ] || [ "$ORIGINAL_VERSION" = "None" ]; then
          echo "‚ùå Could not determine original version from dev stack"
          echo "üîç Available parameters:"
          aws cloudformation describe-stacks \
            --stack-name "urgd-stitch-dev" \
            --query 'Stacks[0].Parameters' \
            --output table \
            --region us-west-2
          exit 1
        fi
        
        echo "‚úÖ Found dev stack version: $ORIGINAL_VERSION"
        echo "üîÑ PROMOTION LOGIC: Dev stack is using version $ORIGINAL_VERSION"
        echo "üîç PROMOTION LOGIC: Will use parameter files from that same version for consistency"
        
        # Set environment variable for use in deployment step
        echo "ORIGINAL_VERSION=$ORIGINAL_VERSION" >> $GITHUB_ENV
        
        # Download parameter files from the original dev build
        mkdir -p parameter-files
        echo "üì• Downloading parameter files from original dev build version: $ORIGINAL_VERSION"
        aws s3 cp "s3://urgd-applicationdata/stitch/cloudformation/$ORIGINAL_VERSION/dev.json" "parameter-files/dev.json" --region us-west-2
        aws s3 cp "s3://urgd-applicationdata/stitch/cloudformation/$ORIGINAL_VERSION/staging.json" "parameter-files/staging.json" --region us-west-2
        aws s3 cp "s3://urgd-applicationdata/stitch/cloudformation/$ORIGINAL_VERSION/prod.json" "parameter-files/prod.json" --region us-west-2
        
        echo "‚úÖ PROMOTION: Parameter files copied from dev stack version: $ORIGINAL_VERSION"
        echo "‚úÖ PROMOTION: This ensures template and parameters reference the same version"
        
    - name: Prepare website files
      run: |
        echo "üìÅ Website files ready for upload to S3 bucket"
        
    - name: Build Lambda package
      if: github.event_name == 'push' || github.event.inputs.environment == 'dev'
      run: |
        VERSION="${{ needs.version.outputs.version }}"
        echo "üî® Building Lambda package for version: $VERSION"
        
        # Create artifacts directory
        mkdir -p artifacts
        
        # Create a temporary build directory
        BUILD_DIR="/tmp/lambda-build-stitch-${VERSION}"
        mkdir -p "$BUILD_DIR"
        
        # Copy Lambda function files
        cp -r lambdas/* "$BUILD_DIR/"
        
        # Install dependencies using pip
        cd "$BUILD_DIR"
        pip install -r requirements.txt -t .
        cd - > /dev/null
        
        # Create zip file from build directory
        cd "$BUILD_DIR"
        zip -r "/tmp/stitch-function-${VERSION}.zip" . -x "*.git*" "*.DS_Store*" "__pycache__/*" "*.pyc"
        cd - > /dev/null
        
        # Note: Layer dependencies will be available at runtime
        echo "‚úÖ Lambda function package built successfully"
        echo "üì¶ Layer dependencies will be available at runtime"
        
        # Move to artifacts directory
        mv "/tmp/stitch-function-${VERSION}.zip" "artifacts/"
        
        # Clean up build directory
        rm -rf "$BUILD_DIR"
        
        echo "‚úÖ Lambda package built: artifacts/stitch-function-${VERSION}.zip"
        echo "üì¶ Package size: $(du -h artifacts/stitch-function-${VERSION}.zip | cut -f1)"
        
    - name: Upload artifacts to S3
      if: github.event_name == 'push' || github.event.inputs.environment == 'dev'
      run: |
        VERSION="${{ needs.version.outputs.version }}"
        echo "üì¶ Uploading artifacts for version: $VERSION"
        
        # Upload Lambda package to artifacts folder (broadcast style)
        aws s3 cp artifacts/stitch-function-${VERSION}.zip s3://urgd-applicationdata/stitch/artifacts/${VERSION}/stitch-function-${VERSION}.zip
        echo "‚úÖ Lambda package uploaded to S3 artifacts folder"
        
        # Upload CloudFormation template to cloudformation folder
        # Upload versioned template and parameters to S3
        VERSION="${{ needs.version.outputs.version }}"
        echo "üì§ Uploading CloudFormation template and parameters for version: $VERSION"
        
        aws s3 cp "cloudformation/stitch-infrastructure.yaml" \
          "s3://urgd-applicationdata/stitch/cloudformation/$VERSION/stitch-infrastructure.yaml" \
          --region us-west-2
        
        # Upload parameter files
        aws s3 cp "parameter-files/" \
          "s3://urgd-applicationdata/stitch/cloudformation/$VERSION/" \
          --recursive --region us-west-2
        echo "‚úÖ Parameter files uploaded for version: $VERSION"
        
    - name: Deploy CloudFormation Stack
      id: cloudfront
      env:
        GITHUB_EVENT_NAME: ${{ github.event_name }}
        ENV_ENVIRONMENT: ${{ env.ENVIRONMENT }}
      run: |
        VERSION="${{ needs.version.outputs.version }}"
        ENVIRONMENT="$ENV_ENVIRONMENT"
        STACK_NAME="urgd-stitch-$ENVIRONMENT"
        
        # Determine which version to use
        if [ "$GITHUB_EVENT_NAME" = "workflow_dispatch" ] && [ "$ENVIRONMENT" != "dev" ]; then
          # This is a promotion - use the same version as dev stack
          PARAM_VERSION="${{ env.ORIGINAL_VERSION }}"
          echo "üöÄ PROMOTION: Deploying $STACK_NAME with version: $PARAM_VERSION (from dev stack)"
        else
          # This is a dev build - use current version
          PARAM_VERSION="$VERSION"
          echo "üöÄ DEV BUILD: Deploying $STACK_NAME with version: $PARAM_VERSION (from current commit)"
        fi
        
        # Download parameter file from S3 to temp location
        TEMP_PARAM_FILE="/tmp/${ENVIRONMENT}-${PARAM_VERSION}.json"
        aws s3 cp "s3://urgd-applicationdata/stitch/cloudformation/$PARAM_VERSION/$ENVIRONMENT.json" "$TEMP_PARAM_FILE" --region us-west-2
        
        # Deploy the stack
        if aws cloudformation describe-stacks --stack-name $STACK_NAME --region us-west-2 >/dev/null 2>&1; then
          echo "Stack exists, updating..."
          # Try to update the stack
          aws cloudformation update-stack \
            --stack-name $STACK_NAME \
            --template-url "https://urgd-applicationdata.s3.us-west-2.amazonaws.com/stitch/cloudformation/$PARAM_VERSION/stitch-infrastructure.yaml" \
            --parameters file://$TEMP_PARAM_FILE \
            --capabilities CAPABILITY_NAMED_IAM \
            --region us-west-2 2>&1 | tee /tmp/update-output.log
          
          UPDATE_EXIT_CODE=${PIPESTATUS[0]}
          
          # Check if the update was successful or if no updates were needed
          if [ $UPDATE_EXIT_CODE -eq 0 ]; then
            echo "‚úÖ Stack update initiated"
            echo "‚è≥ Waiting for stack update to complete..."
            aws cloudformation wait stack-update-complete \
              --stack-name $STACK_NAME \
              --region us-west-2
          elif grep -q "No updates are to be performed" /tmp/update-output.log; then
            echo "‚úÖ Stack is already up to date - no changes needed"
          else
            echo "‚ùå Stack update failed"
            cat /tmp/update-output.log
            exit 1
          fi
        else
          echo "Stack does not exist, creating..."
          aws cloudformation create-stack \
            --stack-name $STACK_NAME \
            --template-url "https://urgd-applicationdata.s3.us-west-2.amazonaws.com/stitch/cloudformation/$PARAM_VERSION/stitch-infrastructure.yaml" \
            --parameters file://$TEMP_PARAM_FILE \
            --capabilities CAPABILITY_NAMED_IAM \
            --region us-west-2
          
          echo "‚è≥ Waiting for stack creation to complete..."
          aws cloudformation wait stack-create-complete \
            --stack-name $STACK_NAME \
            --region us-west-2
        fi
        
        # Clean up temp file
        rm -f "$TEMP_PARAM_FILE"
        
        echo "‚úÖ Stitch stack $STACK_NAME deployed successfully"
        
        # Register with Shield if this was the first deployment
        if [ "$SKIP_REGISTRATION" = "true" ]; then
          echo "üîó Registering Stitch with Shield after stack creation..."
          
          # Get Stitch callback Lambda ARN from the newly created stack
          CALLBACK_ARN=$(aws cloudformation describe-stacks \
            --stack-name "$STACK_NAME" \
            --query 'Stacks[0].Outputs[?OutputKey==`ShieldCallbackLambdaArn`].OutputValue' \
            --output text \
            --region us-west-2)
          
          if [ "$CALLBACK_ARN" != "None" ] && [ -n "$CALLBACK_ARN" ]; then
            echo "‚úÖ Stitch callback Lambda ARN: $CALLBACK_ARN"
            
            # Use Shield registration Lambda ARN from environment variable
            echo "üîç Using Shield registration Lambda ARN: $SHIELD_REGISTRATION_ARN"
            
            # Call Shield registration Lambda using Python script
            export CALLBACK_ARN
            export SHIELD_REGISTRATION_ARN
            export APP_NAME="stitch"
            
            # Install boto3 if not available (suppress all output except errors)
            pip3 install boto3 --quiet --disable-pip-version-check 2>/dev/null || pip3 install boto3 --quiet
            
            python3 scripts/register-with-shield.py > response.json
            
            # Check registration response
            if [ -f response.json ]; then
              REGISTRATION_SUCCESS=$(cat response.json | jq -r '.body.registration_successful')
              if [ "$REGISTRATION_SUCCESS" = "true" ]; then
                echo "‚úÖ Shield registration successful after stack creation"
                rm -f response.json
              else
                echo "‚ùå Shield registration failed after stack creation"
                echo "üîç Registration response:"
                cat response.json
                rm -f response.json
                exit 1
              fi
            else
              echo "‚ùå No response from Shield registration Lambda"
              exit 1
            fi
          else
            echo "‚ùå Could not get Stitch callback Lambda ARN after stack creation"
            exit 1
          fi
        fi
        
        # Get CloudFront Distribution ID for WAF association
        STACK_NAME="urgd-stitch-${{ env.ENVIRONMENT }}"
        REGION="${{ secrets.AWS_REGION || 'us-west-2' }}"
        
        CLOUDFRONT_ID=$(aws cloudformation describe-stacks \
          --stack-name "$STACK_NAME" \
          --region "$REGION" \
          --query 'Stacks[0].Outputs[?OutputKey==`CloudFrontDistributionId`].OutputValue' \
          --output text)
        
        echo "CLOUDFRONT_ID=$CLOUDFRONT_ID" >> $GITHUB_OUTPUT
        echo "‚úÖ CloudFront Distribution ID: $CLOUDFRONT_ID"

        
    - name: Upload website to S3
      run: |
        # Get the website bucket name directly from the stack
        WEBSITE_BUCKET=$(aws cloudformation describe-stacks \
          --stack-name urgd-stitch-${{ env.ENVIRONMENT }} \
          --query 'Stacks[0].Outputs[?OutputKey==`WebsiteBucketName`].OutputValue' \
          --output text)
        
        # Get the API Gateway URL from the stack and append /v1/convert/svg path
        API_BASE_URL=$(aws cloudformation describe-stacks \
          --stack-name urgd-stitch-${{ env.ENVIRONMENT }} \
          --query 'Stacks[0].Outputs[?OutputKey==`ApiUrl`].OutputValue' \
          --output text)
        API_URL="${API_BASE_URL}/v1/convert/svg"
        
        echo "Uploading website to bucket: $WEBSITE_BUCKET"
        echo "API Gateway URL: $API_URL"
        
        # Create a temporary directory for the website
        mkdir -p temp-website
        cp -r website/* temp-website/
        
        # Update the API URL in the website based on environment
        ENVIRONMENT="${{ env.ENVIRONMENT }}"
        if [ "$ENVIRONMENT" = "prod" ]; then
          API_URL="https://api.stitch.urgd.dev/v1/convert/svg"
          WEBSITE_URL="https://stitch.urgdstudios.com"
        else
          API_URL="https://api-${ENVIRONMENT}.stitch.urgd.dev/v1/convert/svg"
          WEBSITE_URL="https://${ENVIRONMENT}.stitch.urgdstudios.com"
        fi
        
        # Replace the API URL in the HTML file
        sed -i "s|https://api-dev.stitch.urgd.dev/v1/convert/svg|$API_URL|g" temp-website/index.html
        
        # Replace Open Graph URLs for social media previews
        sed -i "s|content=\"\"|content=\"$WEBSITE_URL\"|g" temp-website/index.html
        sed -i "s|href=\"\"|href=\"$WEBSITE_URL\"|g" temp-website/index.html
        sed -i "s|content=\"\"|content=\"$WEBSITE_URL/assets/urgd-logo.png\"|g" temp-website/index.html
        
        
        # Upload website files to the S3 website bucket
        aws s3 cp temp-website/ s3://$WEBSITE_BUCKET/ --recursive
        
        # Clean up
        rm -rf temp-website/
        
        echo "Website uploaded successfully with dynamic API URL!"
        
        
    - name: Configure AWS credentials (us-east-1)
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: arn:aws:iam::198919428218:role/urgd-stitch-deploy
        aws-region: us-east-1
        audience: sts.amazonaws.com
        
    - name: Associate WAF with CloudFront
      id: waf
      if: steps.cloudfront.outputs.CLOUDFRONT_ID != ''
      run: |
        CLOUDFRONT_ID="${{ steps.cloudfront.outputs.CLOUDFRONT_ID }}"
        
        echo "üîó Associating consolidated WAF with CloudFront..."
        
        WAF_SSM_PARAM="/urgd/waf/web_acl_arn"
        
        WAF_ARN=$(aws ssm get-parameter \
          --name "$WAF_SSM_PARAM" \
          --query 'Parameter.Value' \
          --output text \
          --region us-east-1)
        
        if [ "$WAF_ARN" = "None" ] || [ -z "$WAF_ARN" ]; then
          echo "‚ùå WAF ARN not found in SSM parameter: $WAF_SSM_PARAM"
          exit 1
        fi
        
        echo "‚úÖ WAF ARN: $WAF_ARN"
        echo "WAF_ARN=$WAF_ARN" >> $GITHUB_OUTPUT
        echo "‚úÖ CloudFront Distribution ID: $CLOUDFRONT_ID"
        
        # Get AWS Account ID
        AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text --region us-east-1)
        echo "‚úÖ AWS Account ID: $AWS_ACCOUNT_ID"
        
        # Get the current distribution configuration
        echo "üìã Getting current distribution configuration..."
        aws cloudfront get-distribution-config \
          --id "$CLOUDFRONT_ID" \
          --region us-east-1 > /tmp/distribution-response.json
        
        ETAG=$(jq -r '.ETag' /tmp/distribution-response.json)
        echo "‚úÖ ETag: $ETAG"
        
        # Extract the distribution config
        jq '.DistributionConfig' /tmp/distribution-response.json > /tmp/distribution-config.json
        
        # Add WAF to the distribution configuration
        echo "üîß Adding WAF to distribution configuration..."
        jq --arg webacl "$WAF_ARN" '.WebACLId = $webacl' /tmp/distribution-config.json > /tmp/distribution-config-updated.json
        
        # Update the CloudFront distribution
        echo "üöÄ Updating CloudFront distribution with WAF..."
        aws cloudfront update-distribution \
          --id "$CLOUDFRONT_ID" \
          --distribution-config file:///tmp/distribution-config-updated.json \
          --if-match "$ETAG" \
          --region us-east-1
        
        echo "‚úÖ WAF successfully associated with CloudFront distribution"
        
    - name: Deploy API Gateway Changes
      run: |
        set -euo pipefail
        
        ENVIRONMENT="${{ env.ENVIRONMENT }}"
        STACK_NAME="urgd-stitch-$ENVIRONMENT"
        REGION="${{ secrets.AWS_REGION || 'us-west-2' }}"
        
        echo "üöÄ Deploying API Gateway to $ENVIRONMENT stage..."
        API_GATEWAY_ID=$(aws cloudformation describe-stacks \
          --stack-name "$STACK_NAME" \
          --query 'Stacks[0].Outputs[?OutputKey==`ApiGatewayId`].OutputValue' \
          --output text \
          --region "$REGION")
        
        if [ -z "$API_GATEWAY_ID" ] || [ "$API_GATEWAY_ID" = "None" ]; then
          echo "‚ö†Ô∏è  ApiGatewayId output missing; falling back to REST API lookup"
          API_GATEWAY_ID=$(aws apigateway get-rest-apis \
            --region "$REGION" \
            --query "items[?name=='urgd-stitch-svg-converter-api-$ENVIRONMENT'].id" \
            --output text)
        fi
        
        if [ -z "$API_GATEWAY_ID" ] || [ "$API_GATEWAY_ID" = "None" ]; then
          echo "‚ùå Could not resolve API Gateway ID"
          exit 1
        fi
        
        echo "üîó API Gateway ID: $API_GATEWAY_ID"
        
        # Create new deployment to activate CloudFormation changes
        DEPLOYMENT_ID=$(aws apigateway create-deployment \
          --rest-api-id "$API_GATEWAY_ID" \
          --stage-name "$ENVIRONMENT" \
          --description "Deploy CloudFormation changes - $(date -u +%Y-%m-%dT%H:%M:%SZ)" \
          --region "$REGION" \
          --query 'id' \
          --output text)
        
        echo "‚úÖ API Gateway deployment created: $DEPLOYMENT_ID"
        echo "‚úÖ API Gateway changes are now active"
        
    - name: Get deployment URLs
      run: |
        STACK_NAME="urgd-stitch-${{ env.ENVIRONMENT }}"
        REGION="${{ secrets.AWS_REGION || 'us-west-2' }}"
        CLOUDFRONT_ID="${{ steps.cloudfront.outputs.CLOUDFRONT_ID }}"
        WAF_ARN="${{ steps.waf.outputs.WAF_ARN }}"
        
        echo "üéâ Deployment Summary"
        echo "==================="
        echo "Stack Name: $STACK_NAME"
        echo "Region: $REGION"
        echo "CloudFront Distribution ID: $CLOUDFRONT_ID"
        echo "WAF ARN: $WAF_ARN"
        echo "Deployed by: $GITHUB_ACTOR"
        echo "Workflow run: $GITHUB_RUN_ID"
        echo "Commit: $GITHUB_SHA"
        echo ""
        echo "===================="
        
        # Get API Gateway URL (use custom domain if available)
        API_URL=$(aws cloudformation describe-stacks \
          --stack-name "$STACK_NAME" \
          --region "$REGION" \
          --query 'Stacks[0].Outputs[?OutputKey==`CustomApiUrl`].OutputValue' \
          --output text)
        
        # Fallback to default API URL if custom domain not available
        if [ "$API_URL" == "None" ] || [ -z "$API_URL" ]; then
          API_URL=$(aws cloudformation describe-stacks \
            --stack-name "$STACK_NAME" \
            --region "$REGION" \
            --query 'Stacks[0].Outputs[?OutputKey==`ApiUrl`].OutputValue' \
            --output text)
        fi
        echo "üîó API Gateway URL: $API_URL"
        
        # Get CloudFront URL (use custom domain if available)
        CLOUDFRONT_URL=$(aws cloudformation describe-stacks \
          --stack-name "$STACK_NAME" \
          --region "$REGION" \
          --query 'Stacks[0].Outputs[?OutputKey==`CustomWebsiteUrl`].OutputValue' \
          --output text)
        
        # Fallback to default CloudFront URL if custom domain not available
        if [ "$CLOUDFRONT_URL" == "None" ] || [ -z "$CLOUDFRONT_URL" ]; then
          CLOUDFRONT_URL=$(aws cloudformation describe-stacks \
            --stack-name "$STACK_NAME" \
            --region "$REGION" \
            --query 'Stacks[0].Outputs[?OutputKey==`CloudFrontUrl`].OutputValue' \
            --output text)
        fi
        
        if [ "$CLOUDFRONT_URL" != "None" ] && [ -n "$CLOUDFRONT_URL" ]; then
          echo "‚òÅÔ∏è  CloudFront URL: $CLOUDFRONT_URL"
          echo "::notice::Stitch is deployed! Access it at: $CLOUDFRONT_URL"
        else
          echo "::notice::Stitch is deployed! Access it at: $API_URL"
        fi
